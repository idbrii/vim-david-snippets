priority -50

global !p
def csv_to_dict(text):
	return ',\n'.join(['"{key}": {key}'.format(key = k.strip()) for i,k in enumerate(text.split(','))])
endglobal

# My stuff {{{1

snippet log "Log a message" w
printt($1)
endsnippet

# As you type comma-separated parameters on the right, {n} values appear in the
# format string.
# TODO: Add support for {key} and key=value.
snippet fmt "String format" w
print(`!p
text = ' '.join([('{k%s}' % i) for i,k in enumerate(t[1].split(','))])
dict_text = csv_to_dict(t[1])
snip.rv = '"{}".format({{\n{}\n}})'.format(text, dict_text)
`) # ${1:${VISUAL:data}}
endsnippet

# As you type comma-separated parameters on the right, val={n} values appear in
# the format string.
snippet dump "String format: dump out data" w
print(`!p
dict_text = csv_to_dict(t[1])
snip.rv = '{{\n{}\n}}'.format(dict_text)
`) # ${1:${VISUAL:data}}
endsnippet

snippet trace "Print a stack trace" b
print_stack()
endsnippet

snippet append "Add to end of array" b
${1:${VISUAL:array}}.append(${2:entry})
endsnippet

# Standard stuff {{{1

snippet var "Declare variable with type inference"
var $1 := $2
endsnippet

# There are now a bunch of different ones of these, but this is the most comon.
snippet pub "Public (tunable) variable with range" b
@export_range(${4:min}, ${5:max}, ${6:step}) var $1 := $2
endsnippet

snippet pubnode "Inspector-set node path" b
@export(NodePath) var $1_path = null
onready var ${1:node} := get_node($1_path)
endsnippet

snippet with "with" b
with ${1:expr}`!p snip.rv = " as " if t[2] else ""`${2:var}:
	${3:${VISUAL:pass}}
$0
endsnippet

snippet assert "Assertion" b
assert(${1:cond}, ${2:optional message})
endsnippet

# Loops {{{1

snippet wh "while" b
while ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet


snippet for "for loop" b
for ${1:item} in ${2:iterable}:
	${3:${VISUAL:pass}}
endsnippet

snippet forchild "foreach over child nodes" b
for ${1:item} in ${2:x.}get_children():
	${3:${VISUAL:pass}}
endsnippet

snippet fordesc "foreach over all descendant nodes" b
var waiting := get_children()
while not waiting.empty():
	var node := waiting.pop_back() as Node
	waiting.append_array(node.get_children())
	${3:${VISUAL:pass}}
endsnippet


# Class and Method {{{1

snippet class "class with docstrings" b
class ${1:Name}:
	$0
endsnippet

snippet !(static )?fun|def! "function with docstrings" br
`!p snip.rv = match.group(1) or ""`func ${1:function}(${2:args}):
	${3:${VISUAL:pass}}
endsnippet

snippet im "Import a type" b
const $1 = preload("res://$2.gd")
endsnippet

# If / Else / Elif {{{1

snippet if "If" b
if ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet

snippet ife "If / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
else:
	${3:pass}
endsnippet

snippet ifee "If / Elif / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
elif ${3:condition}:
	${4:pass}
else:
	${5:pass}
endsnippet

snippet /ma(tch)?/ "match statement" brm
match ${1:pivot}:`!p
if snip.v.text:
	lines = snip.v.text.splitlines()
	enum_name = re.sub(r"\s*enum \s*(\b\w+\b).*", r"\1", lines[0])
	lines = [re.sub(r"\s+(\w+),?.*", r"\1:", line) for line in lines if "}" not in line]
	snip >> 1
	for pair in lines[1:]:
		snip += f"{enum_name}.{pair}"
		snip >> 1
		snip += "pass"
		snip << 1
	snip << 1
else:
	snip >> 1
	snip += ""
`$0
endsnippet



# Exceptions {{{1

snippet try "Try / Except" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
endsnippet

snippet trye "Try / Except / Else" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet tryf "Try / Except / Finally" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet tryef "Try / Except / Else / Finally" b
try:
	${1:${VISUAL:pass}}
except${2: ${3:Exception} as ${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet


snippet event "Emit a signal (Push an event)" b
${1:signal}.emit(${2:args})
endsnippet

snippet event "Declare a signal (Define an event)" b
signal ${1:name}(${2:args})
endsnippet

snippet event "Connect to signal (Listen for event)" b
self.${1:signal name}.connect(_on_$1)
func _on_$1():
	pass
endsnippet


# plugin: debug_draw_3d {{{1
# https://github.com/DmitriySalnikov/godot_debug_draw_3d

snippet dshape "Add debug_draw_3d shape" b
DebugDraw.draw_${1:sphere,cylinder,box,aabb,line,ray,arrow,square,position}(${2:pos}, Vector3(1, 2, 1), ${4:Color.${3:green}})
endsnippet

snippet dtext "Add debug_draw_3d text" b
DebugDraw.set_text("${1:key}", "${2:text}")
endsnippet


# vim:ft=snippets:
