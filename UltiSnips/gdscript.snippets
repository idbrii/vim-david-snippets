priority -50

global !p
def csv_to_dict(text):
	return ',\n'.join(['"{key}": {key}'.format(key = k.strip()) for i,k in enumerate(text.split(','))])
endglobal

# My stuff {{{1

snippet log "Log a message" w
printt($1)
endsnippet

# As you type comma-separated parameters on the right, {n} values appear in the
# format string.
# TODO: Add support for {key} and key=value.
snippet fmt "String format" w
print(`!p
text = ' '.join([('{k%s}' % i) for i,k in enumerate(t[1].split(','))])
dict_text = csv_to_dict(t[1])
snip.rv = '"{}".format({{\n{}\n}})'.format(text, dict_text)
`) # ${1:${VISUAL:data}}
endsnippet

# As you type comma-separated parameters on the right, val={n} values appear in
# the format string.
snippet dump "String format: dump out data" w
print(`!p
dict_text = csv_to_dict(t[1])
snip.rv = '{{\n{}\n}}'.format(dict_text)
`) # ${1:${VISUAL:data}}
endsnippet

snippet trace "Print a stack trace" b
print_stack()
endsnippet

snippet append "Add to end of array" b
${1:${VISUAL:array}}.append(${2:entry})
endsnippet

# Standard stuff {{{1

snippet var "Declare variable with type inference"
var $1 := $2
endsnippet

snippet pub "Public (tunable) variable" b
export(${3:float}, ${4:min}, ${5:max}, ${6:step}) var $1 := $2
endsnippet

snippet with "with" b
with ${1:expr}`!p snip.rv = " as " if t[2] else ""`${2:var}:
	${3:${VISUAL:pass}}
$0
endsnippet

snippet assert "Assertion" b
assert(${1:cond}, ${2:optional message})
endsnippet

# Loops {{{1

snippet wh "while" b
while ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet


snippet for "for loop" b
for ${1:item} in ${2:iterable}:
	${3:${VISUAL:pass}}
endsnippet

snippet forchild "foreach over child nodes" b
for ${1:item} in ${2:x.}get_children():
	${3:${VISUAL:pass}}
endsnippet

snippet fordesc "foreach over all descendant nodes" b
var waiting := get_children()
while not waiting.empty():
	var node := waiting.pop_back() as Node
	waiting.append_array(node.get_children())
	${3:${VISUAL:pass}}
endsnippet


# Class and Method {{{1

snippet class "class with docstrings" b
class ${1:Name}:
	$0
endsnippet

snippet !(static )?fun|def! "function with docstrings" br
`!p snip.rv = match.group(1) or ""`func ${1:function}(${2:args}):
	${3:${VISUAL:pass}}
endsnippet

snippet im "Import a type" b
const $1 = preload("res://$2.gd")
endsnippet

# If / Else / Elif {{{1

snippet if "If" b
if ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet

snippet ife "If / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
else:
	${3:pass}
endsnippet

snippet ifee "If / Elif / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
elif ${3:condition}:
	${4:pass}
else:
	${5:pass}
endsnippet


# Exceptions {{{1

snippet try "Try / Except" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
endsnippet

snippet trye "Try / Except / Else" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet tryf "Try / Except / Finally" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet tryef "Try / Except / Else / Finally" b
try:
	${1:${VISUAL:pass}}
except${2: ${3:Exception} as ${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet



# vim:ft=snippets:
